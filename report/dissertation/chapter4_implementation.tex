\chapter{Implementation}
This chapter will focus on the implementation of various methods for generating a discrete distance field. It will start
with a basic brute-force approach before delving into optimizations and other algorithms. Each implementation will
include a short performance test for comparison between different implementations.

\section{Brute-force Approach}
A brute-force implementation for calculating the discrete distance field given a voxel grid is the most straight-forward
to implement but will suffer from performance; especially as world sizes get larger.

To compute the distance field for a voxel grid using a brute-force approach, we consider a voxel, \(V\) at \((x, y, z)\). The
algorithm starts iterating from the origin of the world \((0, 0, 0)\) and progresses incrementally along each axis of
the grid. For every voxel in the grid, the Manhattan distance is calculated to \(V\). This exhaustive method, while
producing an accurate distance field, must explore every other possible coordinate within the grid; this can be seen in
Algorithm~\ref{alg:brute_force}.

In the worst-case scenario, the algorithm must evaluate the distance for all \(N^3\), where \(N\) is the size of one
axis and the grid has uniform dimensions. This, the worst-case complexity is \(O(N^3)\). In the best-case, when the
voxel \(V\) is located near the origin a complexity of \(O(1)\) can be achieved, but this is highly unlikely.

\begin{algorithm}
    \caption{Brute Force Distance Field Calculation}
    \label{alg:brute_force}
    \begin{algorithmic}[1]
        \STATE \textbf{Input:} Voxel grid size \(N\), Voxel location \((x, y, z)\)
        \STATE \textbf{Output:} Distance field grid \(D\)
        \STATE Initialize \(D[i][j][k] \gets N\) for all \(i, j, k \in [0, N-1]\)
        \FOR{\(i = 0\) to \(N-1\)}
        \FOR{\(j = 0\) to \(N-1\)}
        \FOR{\(k = 0\) to \(N-1\)}
        \STATE \(d \gets |i - x| + |j - y| + |x - z|\) \COMMENT{Manhattan distance calculation, this will be common to
            all implementations.}
        \IF{\(d < D[i][j][k]\)}
        \STATE \(D[i][j][k] \gets d\) \COMMENT{Write only the shortest distance to the output.}
        \ENDIF
        \ENDFOR
        \ENDFOR
        \ENDFOR
        \STATE \textbf{Return:} \(D\)
    \end{algorithmic}
\end{algorithm}

\subsection{Performance Results}
At very small world sizes, the performance of the brute-force algorithm is sufficient; however the performance gets
exponentially worse the larger the world becomes. At a world size above \(256^3\), the amount of work required by each
warp on the GPU becomes too large resulting in the application crashing, as such the testing for this only went to a
world size of \(128^3\).

\begin{table}[h!]
    \centering
    \sisetup{
        table-format=3.3,
        round-mode=places,
        round-precision=3
    }
    \vspace{0.5em}
    \begin{tabular}{l|*{5}{c}}
        \toprule
        \textbf{World Size} & \textbf{\(8^3\)} & \textbf{\(16^3\)} & \textbf{\(32^3\)} & \textbf{\(64^3\)} & \textbf{\(128^3\)} \\
        \midrule
        \textbf{Avg. FPS}   & 142.22890        & 142.335887        & 129.15436         & 2.26601           & 0.03938            \\
        \bottomrule
    \end{tabular}
    \caption{Frame rate of the brute-force algorithm at varying world sizes with a simulation speed of 10 updates/sec.}
\end{table}

\begin{table}[h!]
    \centering
    \sisetup{
        table-format=3.3,
        round-mode=places,
        round-precision=3
    }
    \vspace{0.5em}
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{l|*{5}{c}}
            \toprule
            \textbf{World Size}               & \textbf{\(8^3\)}  & \textbf{\(16^3\)}     & \textbf{\(32^3\)}      & \textbf{\(64^3\)}      & \textbf{\(128^3\)}     \\
            \midrule
            \textbf{Avg. Time (ms)}           & 0.24165356        & 1.3928156             & 10.199081              & 387.77307              & 27297.08               \\
            \textbf{Std. Deviation (ms)}      & 0.024596296       & 0.26439393            & 0.45690483             & 35.218475              & 63.497536              \\
            \textbf{Confidence Interval (ms)} & (0.1586, 0.26592) & (1.3709755, 1.416557) & (10.172742, 10.225421) & (381.69547, 393.85068) & (27262.563, 27331.598) \\
            \bottomrule
        \end{tabular}
    }
    \caption{Distance field compute shader execution time using the brute-force algorithm.}
    \label{tab:brute_force}
\end{table}

The results in Table~\ref{tab:brute_force} highlight how a brute-force approach is unsuitable for large dynamic worlds.
A common optimization is chunking to split a large world into smaller ``chunks'' as described in~\ref{sec:chunking}.

\section{Splitting a World into Chunks} \label{sec:chunking}
Now we are talking.
