\chapter{Implementation}
This chapter will focus on the implementation of various methods for generating a discrete distance field. It will start
with a basic brute-force approach before delving into optimizations and other algorithms. Each implementation will
include a short performance test for comparison between different implementations.

\section{Brute-force Approach}
A brute-force implementation for calculating the discrete distance field given a voxel grid is the most straight-forward
to implement but will suffer from performance; especially as world sizes get larger.

To compute the distance field for a voxel grid using a brute-force approach, we consider a voxel, \(V\) at
\((x, y, z)\). The algorithm starts iterating from the origin of the world \((0, 0, 0)\) and progresses incrementally
along each axis of the grid. For every voxel in the grid, the Manhattan distance is calculated to \(V\). This exhaustive
method, while producing an accurate distance field, must explore every other possible coordinate within the grid; this
can be seen in Algorithm~\ref{alg:brute_force}.

In the worst-case scenario, the algorithm must evaluate the distance for all \(N^3\), where \(N\) is the size of one
axis and the grid has uniform dimensions. This, the worst-case complexity is \(O(N^3)\). In the best-case, when the
voxel \(V\) is located near the origin a complexity of \(O(1)\) can be achieved, but this is highly unlikely.

\begin{algorithm}
    \caption{Brute Force Distance Field Calculation}
    \label{alg:brute_force}
    \begin{algorithmic}[1]
        \REQUIRE Voxel grid size \(N\), Voxel grid \(V\), Voxel location \((x, y, z)\)
        \ENSURE Distance field grid \(D\)
        \STATE Initialize \(D[i][j][k] \gets N\) for all \(i, j, k \in [0, N-1]\)
        \FOR{\(i = 0\) to \(N-1\)}
        \FOR{\(j = 0\) to \(N-1\)}
        \FOR{\(k = 0\) to \(N-1\)}
        \IF{\(V[i][j][k]\) is solid}
        \STATE \(d \gets |i - x| + |j - y| + |x - z|\) \COMMENT{Manhattan distance calculation, this will be common to
            all implementations.}
        \IF{\(d < D[i][j][k]\)}
        \STATE \(D[i][j][k] \gets d\) \COMMENT{Write only the shortest distance to the output.}
        \ENDIF
        \ENDIF
        \ENDFOR
        \ENDFOR
        \ENDFOR
        \STATE \textbf{Return:} \(D\)
    \end{algorithmic}
\end{algorithm}

\subsection{Performance Results}
At very small world sizes, the performance of the brute-force algorithm is sufficient; however the performance gets
exponentially worse the larger the world becomes. At a world size above \(256^3\), the amount of work required by each
warp on the GPU becomes too large resulting in the application crashing, as such the testing for this only went to a
world size of \(128^3\).

\begin{table}[h]
    \centering
    \sisetup{
        table-format=3.3,
        round-mode=places,
        round-precision=3
    }
    \vspace{0.5em}
    \begin{tabular}{l|*{5}{c}}
        \toprule
        \textbf{World Size} & \textbf{\(8^3\)} & \textbf{\(16^3\)} & \textbf{\(32^3\)} & \textbf{\(64^3\)} & \textbf{\(128^3\)} \\
        \midrule
        \textbf{Avg. FPS}   & 142.33702        & 142.335887        & 91.44403          & 2.30128           & 0.04184            \\
        \bottomrule
    \end{tabular}
    \caption{Frame rate of the brute-force algorithm at varying world sizes with a modification every 200ms.}
    \label{tab:brute_force_fps}
\end{table}

\begin{table}[h]
    \centering
    \sisetup{
        table-format=3.3,
        round-mode=places,
        round-precision=3
    }
    \vspace{0.5em}
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{l|*{5}{c}}
            \toprule
            \textbf{World Size}               & \textbf{\(8^3\)}         & \textbf{\(16^3\)}      & \textbf{\(32^3\)}    & \textbf{\(64^3\)}    & \textbf{\(128^3\)}     \\
            \midrule
            \textbf{Avg. Time (ms)}           & 0.13085426               & 0.72909933             & 8.415086             & 431.46756            & 25854.305              \\
            \textbf{Std. Deviation (ms)}      & 0.07906039               & 0.72129595             & 0.6034345            & 23.69193             & 43.82031               \\
            \textbf{Confidence Interval (ms)} & (0.12865908, 0.13304944) & (0.7251273, 0.7330714) & (8.400318, 8.429853) & (428.5129, R34.4222) & (25830.484, 25878.125) \\
            \bottomrule
        \end{tabular}
    }
    \caption{Distance field compute shader execution time using the brute-force algorithm.}
    \label{tab:brute_force}
\end{table}

The results in Table~\ref{tab:brute_force} highlight how a brute-force approach is unsuitable for large dynamic worlds.
A common optimization is chunking to split a large world into smaller ``chunks'' as described in~\ref{sec:chunking}.

\section{Splitting a World into Chunks} \label{sec:chunking}
Partitioning, or chunking, is a common approach to divide a large problem into smaller manageable problems. In the
context of voxels world, sparse voxel octrees (SVO) are an approach for dividing a large dense representation of a voxel
grid into a more sparse format with data only stored where it's needed; this makes it more efficient to process and
render~\cite{laine2010efficient,mileff2019simplified,van2015real}.

Given that a brute-force approach has acceptable performance at a world size of \(16^3\), as can be seen in Table
\ref{tab:brute_force}, we can divide the whole world into smaller \(16^3\) chunks. This will allow for updates in one
chunk to be localized, as such updates will not be required to update the whole world reducing the amount of iterations
required to update a distance field.

For a \(512^3\) sized world, we could divide it into \(32,768\) chunks each with a size of \(16^3\). A worst-case
complexity for this significantly larger world is now \(O(16^3)\) compared to the \(O(512^3)\) it would otherwise be
without a chunking approach.

Chunks, however, present a significant problem in distance field generation as they can introduce inaccuracies between
chunk borders. This can happen if we don't consider the voxels in an adjacent chunk when calculating distances, there
are three potential solutions to this problem:

\begin{enumerate}
    \item When iterating over a chunk, iterate over a size \(X + 2, Y + 2, Z + 2\) to introduce ``padding''. Checking
          neighbours that are in padding region will be treated as solid which will introduce a border in the distance field
          that would force rays to march into the beginning of the next chunk.
    \item Include the adjacent chunks as input to the distance field compute shader. Out-of-bounds accesses should
          result in checking neigbouring chunks; however, this expands the number of voxels needed to be checked and will
          still suffer from inaccuracies if the nearest solid voxel is not in a neighbouring chunk.
    \item Combining the first approach, with multiple passes. An initial distance field calculation is computed for each
          chunk independently. To ensure accurate distances at chunk boundaries, another pass through the world can be done
          that includes neighbour information. Multiple, more global, passes will ensure distances eventually converge on the
          correct distance value~\cite{gorobets2023approach,sinharoy1993finding,xu2015fast}.
\end{enumerate}

\subsection{Padding}
The chosen approach at this point, is to introduce padding to an individual chunk when calculating the distance field.
With this approach the worst-case complexity is slightly worse than without using chunking. Without chunks a \(16^3\)
world, has a complexity \(O(N^3)\), with chunks we require padding and so a chunk of the same size would have a
complexity of \(O((N + 2)^3)\).

To account for the ``padding'' around a chunk, out-of-bounds accesses will be treated as a solid voxel.

\begin{algorithm}[H]
    \caption{Get Voxel at \((x, y, z)\)}
    \label{alg:get_voxel}
    \begin{algorithmic}[1]
        \REQUIRE Voxel grid \(V\), position \(x, y, z\)
        \IF{\(x, y, z\) is within bounds of \(V\)}
        \RETURN \(V[x][y][z]\)
        \ELSE
        \RETURN Solid voxel
        \ENDIF
    \end{algorithmic}
\end{algorithm}

The algorithm for the distance field calculation remains largely unchanged except for now using Algorithm
\ref{alg:get_voxel} to access the voxel grid \(V\) instead of direct access. The updated algorithm is now implemented
as follows.

\begin{algorithm}[H]
    \caption{Brute force Distance Field Calculation (With chunks)}
    \begin{algorithmic}[1]
        \REQUIRE Voxel grid size \(N\), Voxel grid \(V\), Voxel location \((x, y, z)\)
        \ENSURE Distance field grid \(D\)
        \STATE Initialize \(D[i][j][k] \gets N\) for all \(i, j, k \in [0, N-1]\)
        \FOR{\(i = -1\) to \(N\)}
        \FOR{\(j = -1\) to \(N\)}
        \FOR{\(k = -1\) to \(N\)}
        \STATE \texttt{voxel} $\gets$ \texttt{Get Voxel at} \((i, j, k)\)
        \IF{\texttt{voxel is solid}}
        \STATE \(d \gets |i - x| + |j - y| + |x - z|\)
        \IF{\(d < D[i][j][k]\)}
        \STATE \(D[i][j][k] \gets d\)
        \ENDIF
        \ENDIF
        \ENDFOR
        \ENDFOR
        \ENDFOR
        \STATE \textbf{Return:} \(D\)
    \end{algorithmic}
\end{algorithm}

\subsection{Performance Results}
Based on the performance results of the brute-force approach, as can be seen in Table~\ref{tab:brute_force}, the
proceeding tests will use a chunk size of \(16^3\). The key improvement in using chunks is that the total world size is
theoretically only limited by the memory consumption. Sufficiently large updates spanning multiple chunks will be less
performant, but we can expect that a small localized update affecting only a couple of chunks will have only marginally
worse performance than the previous approach.

\begin{table}[h!]
    \centering
    \sisetup{
        table-format=3.3,
        round-mode=places,
        round-precision=3
    }
    \vspace{0.5em}
    \begin{tabular}{l|*{5}{c}}
        \toprule
        \textbf{World Size}          & \textbf{\(32^3\)} & \textbf{\(64^3\)} & \textbf{\(128^3\)} & \textbf{\(256^3\)} & \textbf{\(512^3\)} \\
        \midrule
        \textbf{Avg. FPS}            & 141.02969         & 140.32344         & 88.75602           & 22.13375           & 3.37203            \\
        \textbf{Avg. Execution Time} & 0.8090571         & 0.7992149         & 0.7797105          & 0.7632012          & 0.7504562          \\
        \textbf{\% Improvement}      & 54.2251\%         & 5997.63\%         & 212032\%           & Inf\%              & Inf\%              \\
        \bottomrule
    \end{tabular}
    \caption{Frame rate, and execution time, of the brute-force algorithm, when using a chunk size of \(16^3\), at
        varying world sizes with a modification to the world every 200ms. Percentage improvement is the improvement in
        frame rate compared to a comparably sized world without chunks, as demonstrated in Table~\ref{tab:brute_force_fps}.}
\end{table}
