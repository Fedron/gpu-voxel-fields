#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D output_image;

uniform mat4 inverse_view;
uniform mat4 inverse_projection;
uniform vec4 texture_size;

const int INT_MAX = 2147483647;

int world_sdf[8] = int[8](
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
);
vec3 world_min = vec3(0.0);
vec3 world_max = vec3(2.0);

int get_world_sdf(ivec3 pos) {
    if (pos.x >= 0 && pos.x < 2 && pos.y >= 0 && pos.y < 2 && pos.z >= 0 && pos.z < 2) {
        int index = pos.x + (pos.y * 2) + (pos.z * 4);
        return world_sdf[index];
    }
    return INT_MAX;
}

bool intersect_box(vec3 ray_origin, vec3 inv_ray_dir, vec3 box_min, vec3 box_max, out float t_enter, out float t_exit) {
    vec3 t0s = (box_min - ray_origin) * inv_ray_dir;
    vec3 t1s = (box_max - ray_origin) * inv_ray_dir;

    vec3 t_min = min(t0s, t1s);
    vec3 t_max = max(t0s, t1s);

    t_enter = max(max(t_min.x, t_min.y), t_min.z);
    t_exit = min(min(t_max.x, t_max.y), t_max.z);

    return t_enter <= t_exit && t_exit >= 0.0;
}

vec3 calculate_normal(vec3 p) {
    const ivec3 delta = ivec3(1, 0, 0);
    ivec3 pos = ivec3(floor(p));

    float gradient_x = float(get_world_sdf(pos + delta.xyy)) - float(get_world_sdf(pos - delta.xyy));
    float gradient_y = float(get_world_sdf(pos + delta.yxy)) - float(get_world_sdf(pos - delta.yxy));
    float gradient_z = float(get_world_sdf(pos + delta.yyx)) - float(get_world_sdf(pos - delta.yyx));

    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);
    return normalize(normal);
}

float ray_march(vec3 ray_origin, vec3 ray_dir, out vec3 normal, float t_enter, float t_exit, int max_steps) {
    float t = t_enter;
    
    for (int i = 0; i < max_steps; i++) {
        vec3 pos = ray_origin + (t + 0.001) * ray_dir;
        int sdf = get_world_sdf(ivec3(floor(pos)));

        if (sdf == 0) {
            normal = calculate_normal(pos);
            return t;
        } else if (sdf == INT_MAX) {
            break;
        }

        t += float(sdf);

        if (t > t_exit) {
            break;
        }

    }

    return t_exit;
}

vec3 get_ray_direction(vec2 frag_coord) {
    vec2 ndc = (frag_coord / texture_size.xy) * 2.0 - vec2(1.0);

    vec4 clip_space_pos = vec4(ndc, -1.0, 1.0);

    vec4 eye_space_pos = inverse_projection * clip_space_pos;
    eye_space_pos /= eye_space_pos.w;
    vec4 world_space_pos = inverse_view * eye_space_pos;

    vec3 ray_dir = normalize(world_space_pos.xyz - (inverse_view * vec4(0.0, 0.0, 0.0, 1.0)).xyz);
    return ray_dir;
}

void main() {
    vec3 ray_origin = (inverse_view * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 ray_direction = get_ray_direction(gl_GlobalInvocationID.xy);
    vec3 inv_ray_direction = 1.0 / ray_direction;

    float t_enter, t_exit;
    bool hit_world = intersect_box(ray_origin, inv_ray_direction, world_min, world_max, t_enter, t_exit);

    vec3 color = vec3(0.0);
    if (hit_world) {
        vec3 normal;
        float hit_dist = ray_march(ray_origin, ray_direction, normal, t_enter, t_exit, 16);
        if (hit_dist < t_exit) {
            vec3 light_dir = normalize(vec3(1.0, 1.0, -1.0));
            float diffuse = max(dot(normal, light_dir), 0.0);
            color = vec3(diffuse);
        }
    }
    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(color, 0.0));
}