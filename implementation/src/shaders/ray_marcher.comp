#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) buffer DistanceField {
    uint distance_field[512];
};

layout (binding = 1, rgba8) uniform image2D output_image;

uniform vec3 camera_position;
uniform mat4 inverse_view;
uniform mat4 inverse_projection;

uniform vec3 grid_min;
uniform vec3 grid_max;
uniform ivec3 grid_size;

float compute_ao(ivec3 voxel_pos) {
    int neighbor_count = 0;
    for (int dz = -1; dz <= 1; ++dz) {
        for (int dy = -1; dy <= 1; ++dy) {
            for (int dx = -1; dx <= 1; ++dx) {
                ivec3 neighbor_pos = voxel_pos + ivec3(dx, dy, dz);
                if (all(greaterThanEqual(neighbor_pos, ivec3(0))) && 
                    all(lessThan(neighbor_pos, grid_size))) {
                    int neighbor_index = neighbor_pos.z * grid_size.x * grid_size.y +
                                         neighbor_pos.y * grid_size.x +
                                         neighbor_pos.x;
                    if (distance_field[neighbor_index] == 0) {
                        neighbor_count++;
                    }
                }
            }
        }
    }

    return 1.0 - float(neighbor_count) / 27.0;
}

vec4 sky_color(int image_height) {
    return vec4(mix(
        vec3(0.71, 0.85, 0.90),
        vec3(0.0, 0.45, 0.74),
        gl_GlobalInvocationID.y / image_height
    ), 1.0);
}

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(output_image);

    vec2 ndc = (vec2(pixel_coord) / vec2(image_size)) * 2.0 - 1.0;

    vec4 clip = vec4(ndc, 0.0, 1.0);
    vec4 eye = inverse_projection * clip;
    eye = vec4(eye.xy, -1.0, 0.0);

    vec3 ray_dir = normalize((inverse_view * eye).xyz);
    vec3 ray_origin = camera_position;

    vec3 voxel_size = (grid_max - grid_min) / vec3(grid_size);

    vec3 inv_dir = 1.0 / ray_dir;
    vec3 t_min = (grid_min - ray_origin) * inv_dir;
    vec3 t_max = (grid_max - ray_origin) * inv_dir;

    vec3 t_enter = min(t_min, t_max);
    vec3 t_exit = max(t_min, t_max);

    float t_grid_enter = max(max(t_enter.x, t_enter.y), t_enter.z);
    float t_grid_exit = min(min(t_exit.x, t_exit.y), t_exit.z);

    if (t_grid_enter > t_grid_exit || t_grid_exit < 0.0) {
        imageStore(output_image, pixel_coord, sky_color(image_size.y));
        return;
    }

    ray_origin += max(t_grid_enter, 0.0) * ray_dir;

    ivec3 voxel_pos = ivec3(floor((ray_origin - grid_min) / voxel_size));
    voxel_pos = clamp(voxel_pos, ivec3(0), grid_size - 1);

    vec3 t_delta;
    for (int i = 0; i < 3; ++i) {
        if (ray_dir[i] > 0) {
            t_max[i] = ((voxel_pos[i] + 1) * voxel_size[i] + grid_min[i] - ray_origin[i]) / ray_dir[i];
            t_delta[i] = voxel_size[i] / ray_dir[i];
        } else if (ray_dir[i] < 0) {
            t_max[i] = (voxel_pos[i] * voxel_size[i] + grid_min[i] - ray_origin[i]) / ray_dir[i];
            t_delta[i] = -voxel_size[i] / ray_dir[i];
        } else {
            t_max[i] = 1e30;
            t_delta[i] = 1e30;
        }
    }

    for (int step = 0; step < 256; ++step) {
        int voxel_index = voxel_pos.z * grid_size.x * grid_size.y + voxel_pos.y * grid_size.x + voxel_pos.x;
        uint voxel = distance_field[voxel_index];

        if (voxel == 0) {
            float ao = compute_ao(voxel_pos);
            vec4 base_color = vec4(1.0);
            imageStore(output_image, pixel_coord, vec4(base_color.rgb * ao, base_color.a));
            return;
        }

        if (t_max.x < t_max.y) {
            if (t_max.x < t_max.z) {
                voxel_pos.x += int(sign(ray_dir.x));
                t_max.x += t_delta.x;
            } else {
                voxel_pos.z += int(sign(ray_dir.z));
                t_max.z += t_delta.z;
            }
        } else {
            if (t_max.y < t_max.z) {
                voxel_pos.y += int(sign(ray_dir.y));
                t_max.y += t_delta.y;
            } else {
                voxel_pos.z += int(sign(ray_dir.z));
                t_max.z += t_delta.z;
            }
        }

        if (any(lessThan(voxel_pos, ivec3(0))) || any(greaterThanEqual(voxel_pos, grid_size))) {
            break;
        }
    }

    imageStore(output_image, pixel_coord, sky_color(image_size.y));
}